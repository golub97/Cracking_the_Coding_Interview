Let's draw a picture of intersecting linked lists to get a better feel for what is going on. 
Here is a picture of intersecting linked lists:
Page 221
And here is a picture of non-intersecting linked lists:
Page 221
We should be careful here to not inadvertently draw a special case by making the linked lists the same length.
Let's first ask how we would determine if two linked lists intersect. 

Solution #1 Determining if there's an intersection.
How would we detect if two linked lists intersect?
One approach would be to use a hash table and just throw all the linked lists nodes into there. 
We would need to be careful to reference the linked lists by their memory location, not by their value. 

There's an easier way though. 
Observe that two intersecting linked lists will always have the same last node. 
Therefore, we can just traverse to the end of each linked list and compare the last nodes. 
How do we find where the intersection is, though? 

Solution #2 Finding the intersecting node.
One thought is that we could traverse backwards through each linked list. 
When the linked lists "split", that's the intersection. 
Of course, you can't really traverse backwards through a singly linked list. 
If the linked lists were the same length, you could just traverse through them at the same time. 
When they collide, that's your intersection. 
Page 222

When they're not the same length, we'd like to just"chop off"-or ignore-those excess (gray) nodes.
How can we do this? 
Well, if we know the lengths of the two linked lists, then the difference between those two linked lists will tell us how much to chop off. 
We can get the lengths at the same time as we get the tails of the linked lists 
(which we used in the first step to determine if there's an intersection). 

Putting it all together. 
We now have a multistep process. 
1. Run through each linked list to get the lengths and the tails.
2. Compare the tails. If they are different (by reference, not by value), return immediately. There is no intersection.
3. Set two pointers to the start of each linked list.
4. On the longer linked list, advance its pointer by the difference in lengths.
5. Now, traverse on each linked list until the pointers are the same.

This algorithm takes O(A + B) time, where A and B are the lengths of the two linked lists. 
It takes O(1) additional space.
